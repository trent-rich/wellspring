-- Watershed Command Center - Agent Runtime Schema
-- Multi-agent job queue system for AI-powered task processing
-- Based on spec: Email triage, Research, Writing, Monitoring agents

-- ============================================
-- ENUMS
-- ============================================

-- Job status lifecycle
CREATE TYPE agent_job_status AS ENUM (
  'pending',      -- Queued, not yet picked up
  'locked',       -- Being processed by a worker
  'completed',    -- Successfully finished
  'failed',       -- Failed with error
  'cancelled'     -- Manually cancelled
);

-- Types of jobs the agent system can process
CREATE TYPE agent_job_type AS ENUM (
  -- Email processing
  'email_triage',           -- Classify and route incoming email
  'email_draft_reply',      -- Generate reply draft
  'email_summarize_thread', -- Summarize email thread

  -- Research jobs
  'research_web',           -- Web search and synthesis
  'research_codebase',      -- Codebase exploration
  'research_document',      -- Document analysis

  -- Writing jobs
  'write_document',         -- Create document draft
  'write_email',            -- Compose new email
  'write_summary',          -- Generate summary

  -- Monitoring jobs
  'monitor_inbox',          -- Check for new emails
  'monitor_calendar',       -- Check calendar changes
  'monitor_mentions'        -- Check Slack/Monday mentions
);

-- Agent roles
CREATE TYPE agent_role AS ENUM (
  'triage',     -- Email triage and classification
  'research',   -- Research and information gathering
  'writer'      -- Content generation
);

-- Artifact types generated by agents
CREATE TYPE agent_artifact_type AS ENUM (
  'email_draft',      -- Draft email ready for review
  'document',         -- Generated document
  'summary',          -- Summary text
  'research_report',  -- Research findings
  'classification',   -- Classification result (JSON)
  'extracted_tasks',  -- Tasks extracted from content
  'raw_output'        -- Unstructured agent output
);

-- Email thread status for tracking
CREATE TYPE email_thread_status AS ENUM (
  'new',              -- Just arrived, not triaged
  'triaged',          -- Classified, awaiting action
  'action_required',  -- Needs human response
  'draft_ready',      -- AI draft available for review
  'responded',        -- Reply sent
  'archived',         -- No action needed
  'snoozed'           -- Temporarily hidden
);

-- Email priority from triage
CREATE TYPE email_priority AS ENUM (
  'urgent',     -- Needs immediate attention
  'high',       -- Important, respond soon
  'normal',     -- Standard priority
  'low',        -- Can wait
  'fyi'         -- Information only, no response needed
);

-- ============================================
-- AGENT JOBS TABLE (Job Queue)
-- ============================================

CREATE TABLE agent_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Job identification
  job_type agent_job_type NOT NULL,
  priority INT DEFAULT 50 CHECK (priority >= 0 AND priority <= 100),

  -- Status and locking
  status agent_job_status DEFAULT 'pending',
  locked_by TEXT,                           -- Worker ID that claimed this job
  locked_at TIMESTAMPTZ,                    -- When the lock was acquired
  lock_expires_at TIMESTAMPTZ,              -- Lock auto-releases after this time

  -- Input/Output
  input JSONB NOT NULL,                     -- Job-specific input payload
  output JSONB,                             -- Job result (structured per job_type)
  error TEXT,                               -- Error message if failed

  -- Relationships
  parent_job_id UUID REFERENCES agent_jobs(id), -- For chained jobs
  source_email_id UUID,                     -- Link to source email
  source_task_id UUID REFERENCES tasks(id), -- Link to source task
  created_by UUID REFERENCES users(id),     -- User who triggered job (null for automated)

  -- Timing
  attempts INT DEFAULT 0,                   -- Retry counter
  max_attempts INT DEFAULT 3,               -- Max retries before permanent failure
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,

  -- Metadata
  metadata JSONB,                           -- Additional job context
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for job queue polling (most important)
CREATE INDEX idx_agent_jobs_queue ON agent_jobs(status, priority DESC, created_at)
  WHERE status = 'pending';

-- Index for finding locked jobs (for timeout cleanup)
CREATE INDEX idx_agent_jobs_locked ON agent_jobs(lock_expires_at)
  WHERE status = 'locked';

-- Index for job history by type
CREATE INDEX idx_agent_jobs_type ON agent_jobs(job_type, created_at DESC);

-- Index for finding jobs by source
CREATE INDEX idx_agent_jobs_source_email ON agent_jobs(source_email_id)
  WHERE source_email_id IS NOT NULL;

-- ============================================
-- AGENT ARTIFACTS TABLE (Generated Files)
-- ============================================

CREATE TABLE agent_artifacts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Artifact identification
  artifact_type agent_artifact_type NOT NULL,
  title TEXT,

  -- Content
  content TEXT,                             -- Text content (for text-based artifacts)
  content_json JSONB,                       -- Structured content
  storage_path TEXT,                        -- Path in Supabase Storage (for large files)

  -- Relationships
  job_id UUID REFERENCES agent_jobs(id) ON DELETE SET NULL,
  email_id UUID,                            -- Link to source email
  task_id UUID REFERENCES tasks(id),        -- Link to related task

  -- Review workflow
  reviewed_by UUID REFERENCES users(id),
  reviewed_at TIMESTAMPTZ,
  approved BOOLEAN,
  review_notes TEXT,

  -- Metadata
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for finding artifacts by job
CREATE INDEX idx_agent_artifacts_job ON agent_artifacts(job_id);

-- Index for finding unreviewed artifacts
CREATE INDEX idx_agent_artifacts_unreviewed ON agent_artifacts(artifact_type, created_at)
  WHERE reviewed_at IS NULL;

-- ============================================
-- EMAIL THREADS TABLE (Gmail Ingestion)
-- ============================================

CREATE TABLE email_threads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Gmail identifiers
  gmail_thread_id TEXT UNIQUE NOT NULL,
  gmail_history_id TEXT,                    -- For incremental sync

  -- Thread metadata
  subject TEXT NOT NULL,
  snippet TEXT,                             -- Preview text
  participants JSONB,                       -- Array of {email, name}

  -- Classification (from triage agent)
  status email_thread_status DEFAULT 'new',
  priority email_priority,
  category TEXT,                            -- e.g., "meeting_request", "action_item", "newsletter"
  suggested_action TEXT,                    -- AI-suggested next step

  -- Relationships
  assigned_to UUID REFERENCES users(id),
  related_task_id UUID REFERENCES tasks(id),

  -- Counts
  message_count INT DEFAULT 0,
  unread_count INT DEFAULT 0,

  -- Timing
  latest_message_at TIMESTAMPTZ,
  first_message_at TIMESTAMPTZ,
  snoozed_until TIMESTAMPTZ,

  -- Sync metadata
  last_synced_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for thread listing (inbox view)
CREATE INDEX idx_email_threads_inbox ON email_threads(status, latest_message_at DESC)
  WHERE status NOT IN ('archived', 'responded');

-- Index for assigned threads
CREATE INDEX idx_email_threads_assigned ON email_threads(assigned_to, status)
  WHERE assigned_to IS NOT NULL;

-- Index for snoozed threads
CREATE INDEX idx_email_threads_snoozed ON email_threads(snoozed_until)
  WHERE snoozed_until IS NOT NULL AND status = 'snoozed';

-- ============================================
-- EMAILS TABLE (Individual Messages)
-- ============================================

CREATE TABLE emails (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Gmail identifiers
  gmail_message_id TEXT UNIQUE NOT NULL,
  gmail_thread_id TEXT NOT NULL,

  -- Relationship to thread
  thread_id UUID REFERENCES email_threads(id) ON DELETE CASCADE,

  -- Message details
  subject TEXT,
  from_address TEXT NOT NULL,
  from_name TEXT,
  to_addresses JSONB,                       -- Array of {email, name}
  cc_addresses JSONB,
  bcc_addresses JSONB,

  -- Content
  body_text TEXT,                           -- Plain text body
  body_html TEXT,                           -- HTML body
  snippet TEXT,                             -- Preview

  -- Attachments
  has_attachments BOOLEAN DEFAULT FALSE,
  attachments JSONB,                        -- Array of {id, filename, mimeType, size}

  -- Labels and state
  gmail_labels JSONB,                       -- Array of Gmail label IDs
  is_read BOOLEAN DEFAULT FALSE,
  is_starred BOOLEAN DEFAULT FALSE,
  is_draft BOOLEAN DEFAULT FALSE,
  is_sent BOOLEAN DEFAULT FALSE,

  -- Timestamps
  internal_date TIMESTAMPTZ NOT NULL,       -- Gmail's internal date
  received_at TIMESTAMPTZ,

  -- Headers (useful subset)
  headers JSONB,                            -- Key headers like Message-ID, References, In-Reply-To

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for messages in a thread
CREATE INDEX idx_emails_thread ON emails(thread_id, internal_date DESC);

-- Index for Gmail sync
CREATE INDEX idx_emails_gmail ON emails(gmail_thread_id, gmail_message_id);

-- Index for recent emails
CREATE INDEX idx_emails_recent ON emails(internal_date DESC);

-- ============================================
-- JOB QUEUE FUNCTIONS
-- ============================================

-- Function to claim a job from the queue (atomic lock acquisition)
CREATE OR REPLACE FUNCTION claim_agent_job(
  p_worker_id TEXT,
  p_job_types agent_job_type[] DEFAULT NULL,
  p_lock_duration_seconds INT DEFAULT 300
)
RETURNS UUID AS $$
DECLARE
  v_job_id UUID;
BEGIN
  -- Atomic claim using FOR UPDATE SKIP LOCKED
  UPDATE agent_jobs
  SET
    status = 'locked',
    locked_by = p_worker_id,
    locked_at = NOW(),
    lock_expires_at = NOW() + (p_lock_duration_seconds || ' seconds')::INTERVAL,
    attempts = attempts + 1,
    started_at = COALESCE(started_at, NOW()),
    updated_at = NOW()
  WHERE id = (
    SELECT id FROM agent_jobs
    WHERE status = 'pending'
      AND (p_job_types IS NULL OR job_type = ANY(p_job_types))
      AND attempts < max_attempts
    ORDER BY priority DESC, created_at ASC
    FOR UPDATE SKIP LOCKED
    LIMIT 1
  )
  RETURNING id INTO v_job_id;

  RETURN v_job_id;
END;
$$ LANGUAGE plpgsql;

-- Function to complete a job
CREATE OR REPLACE FUNCTION complete_agent_job(
  p_job_id UUID,
  p_worker_id TEXT,
  p_output JSONB DEFAULT NULL
)
RETURNS BOOLEAN AS $$
DECLARE
  v_updated BOOLEAN;
BEGIN
  UPDATE agent_jobs
  SET
    status = 'completed',
    output = p_output,
    completed_at = NOW(),
    locked_by = NULL,
    lock_expires_at = NULL,
    updated_at = NOW()
  WHERE id = p_job_id
    AND locked_by = p_worker_id
    AND status = 'locked';

  GET DIAGNOSTICS v_updated = ROW_COUNT;
  RETURN v_updated > 0;
END;
$$ LANGUAGE plpgsql;

-- Function to fail a job
CREATE OR REPLACE FUNCTION fail_agent_job(
  p_job_id UUID,
  p_worker_id TEXT,
  p_error TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
  v_updated BOOLEAN;
  v_attempts INT;
  v_max_attempts INT;
BEGIN
  SELECT attempts, max_attempts INTO v_attempts, v_max_attempts
  FROM agent_jobs WHERE id = p_job_id;

  UPDATE agent_jobs
  SET
    status = CASE
      WHEN v_attempts >= v_max_attempts THEN 'failed'::agent_job_status
      ELSE 'pending'::agent_job_status
    END,
    error = p_error,
    completed_at = CASE
      WHEN v_attempts >= v_max_attempts THEN NOW()
      ELSE NULL
    END,
    locked_by = NULL,
    lock_expires_at = NULL,
    updated_at = NOW()
  WHERE id = p_job_id
    AND locked_by = p_worker_id
    AND status = 'locked';

  GET DIAGNOSTICS v_updated = ROW_COUNT;
  RETURN v_updated > 0;
END;
$$ LANGUAGE plpgsql;

-- Function to release expired locks (called by cron)
CREATE OR REPLACE FUNCTION release_expired_job_locks()
RETURNS INT AS $$
DECLARE
  v_count INT;
BEGIN
  UPDATE agent_jobs
  SET
    status = 'pending',
    locked_by = NULL,
    locked_at = NULL,
    lock_expires_at = NULL,
    updated_at = NOW()
  WHERE status = 'locked'
    AND lock_expires_at < NOW();

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- HELPER FUNCTIONS
-- ============================================

-- Function to create a triage job for a new email thread
CREATE OR REPLACE FUNCTION create_email_triage_job(
  p_thread_id UUID
)
RETURNS UUID AS $$
DECLARE
  v_job_id UUID;
  v_thread RECORD;
BEGIN
  SELECT * INTO v_thread FROM email_threads WHERE id = p_thread_id;

  INSERT INTO agent_jobs (
    job_type,
    priority,
    input,
    source_email_id,
    metadata
  ) VALUES (
    'email_triage',
    60, -- Default priority for triage
    jsonb_build_object(
      'thread_id', p_thread_id,
      'gmail_thread_id', v_thread.gmail_thread_id,
      'subject', v_thread.subject,
      'snippet', v_thread.snippet
    ),
    p_thread_id,
    jsonb_build_object('auto_created', true)
  )
  RETURNING id INTO v_job_id;

  RETURN v_job_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-create triage job when new thread arrives
CREATE OR REPLACE FUNCTION trigger_email_triage()
RETURNS TRIGGER AS $$
BEGIN
  -- Only trigger for new threads
  IF NEW.status = 'new' THEN
    PERFORM create_email_triage_job(NEW.id);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER email_thread_triage
AFTER INSERT ON email_threads
FOR EACH ROW
EXECUTE FUNCTION trigger_email_triage();

-- ============================================
-- ROW LEVEL SECURITY
-- ============================================

ALTER TABLE agent_jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE agent_artifacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE emails ENABLE ROW LEVEL SECURITY;

-- Jobs: viewable by creator or assigned user
CREATE POLICY agent_jobs_access ON agent_jobs FOR ALL USING (
  created_by = auth.uid() OR
  EXISTS (
    SELECT 1 FROM email_threads et
    WHERE et.id = agent_jobs.source_email_id
    AND et.assigned_to = auth.uid()
  ) OR
  EXISTS (SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin')
);

-- Artifacts: viewable by creator or reviewer
CREATE POLICY agent_artifacts_access ON agent_artifacts FOR ALL USING (
  EXISTS (
    SELECT 1 FROM agent_jobs aj
    WHERE aj.id = agent_artifacts.job_id
    AND aj.created_by = auth.uid()
  ) OR
  reviewed_by = auth.uid() OR
  EXISTS (SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin')
);

-- Email threads: viewable by assigned user
CREATE POLICY email_threads_access ON email_threads FOR ALL USING (
  assigned_to = auth.uid() OR
  EXISTS (SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin')
);

-- Emails: viewable through thread access
CREATE POLICY emails_access ON emails FOR ALL USING (
  EXISTS (
    SELECT 1 FROM email_threads et
    WHERE et.id = emails.thread_id
    AND (et.assigned_to = auth.uid() OR EXISTS (SELECT 1 FROM users WHERE id = auth.uid() AND role = 'admin'))
  )
);

-- ============================================
-- REALTIME SUBSCRIPTIONS
-- ============================================

ALTER PUBLICATION supabase_realtime ADD TABLE agent_jobs;
ALTER PUBLICATION supabase_realtime ADD TABLE agent_artifacts;
ALTER PUBLICATION supabase_realtime ADD TABLE email_threads;

-- ============================================
-- INDEXES FOR COMMON QUERIES
-- ============================================

-- For dashboard: job stats by status
CREATE INDEX idx_agent_jobs_status ON agent_jobs(status, job_type);

-- For job history view
CREATE INDEX idx_agent_jobs_history ON agent_jobs(created_at DESC);

-- For artifacts by type (for review queue)
CREATE INDEX idx_agent_artifacts_type ON agent_artifacts(artifact_type, created_at DESC);

-- ============================================
-- AUDIT LOG EXTENSION
-- ============================================

-- Extend existing audit_log for agent actions
-- (using existing table, just documenting usage)
-- agent actions use entity_type = 'agent_job' or 'agent_artifact'
-- action types: 'job_created', 'job_completed', 'job_failed', 'artifact_created', 'artifact_reviewed'
