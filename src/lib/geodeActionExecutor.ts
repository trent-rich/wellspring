/**
 * GEODE Action Executor
 *
 * Executes the actions defined in GeodeConfirmationTask.pendingActions
 * This includes:
 * - Generating contract emails (drafts in Gmail)
 * - Updating chapter status
 * - Logging author information
 */

import {
  createDraft,
  createDraftWithAttachment,
  isGmailConnected,
  getAttachment,
  findEmailWithAttachment,
  type DraftEmailOptions,
} from './gmailService';
import type { GeodeSuggestedAction, GeodeConfirmationTask } from '../types/geodeEmailEvents';
import { GEODE_STATES, GEODE_CHAPTER_TYPES } from '../types/geode';

// ============================================
// TYPES
// ============================================

export interface ActionExecutionResult {
  actionId: string;
  success: boolean;
  message: string;
  artifacts?: {
    type: 'draft' | 'status_update' | 'log_entry';
    id?: string;
    url?: string;
    details?: Record<string, unknown>;
  }[];
}

export interface TaskExecutionResult {
  taskId: string;
  success: boolean;
  results: ActionExecutionResult[];
  summary: string;
}

// ============================================
// CONTRACT EMAIL TEMPLATES
// ============================================

interface ContractEmailParams {
  authorName: string;
  authorEmail: string;
  stateName: string;
  stateAbbrev: string;
  chapterTitle: string;
  chapterNum: string;
  recipientName: string;
  recipientEmail: string;
  ccEmails?: string[];
}

function generateContractEmailDraft(params: ContractEmailParams): DraftEmailOptions {
  const { authorName, stateName, stateAbbrev, chapterTitle, chapterNum, recipientName, ccEmails } = params;

  const subject = `[GEODE] Author Contract - ${authorName} - ${stateAbbrev} Ch ${chapterNum} ${chapterTitle}`;

  const body = `Hi ${recipientName},

${authorName} has agreed to be the bylined author for Chapter ${chapterNum}: ${chapterTitle} in the ${stateName} State Geothermal Data Report.

**Author Details:**
- Name: ${authorName}
- Email: ${params.authorEmail}
- Chapter: ${chapterNum} - ${chapterTitle}
- Report: ${stateName} GEODE Report

Please generate the contributor contract and send it via Box Sign for signature.

Once the contract is signed by both parties, please let me know so we can proceed with onboarding.

Thank you!

---
_This draft was generated by Wellspring._`;

  return {
    to: [params.recipientEmail],
    cc: ccEmails,
    subject,
    body,
    isHtml: false,
  };
}

interface AccountingEmailParams {
  authorName: string;
  authorEmail: string;
  stateName: string;
  stateAbbrev: string;
  chapterTitle: string;
  chapterNum: string;
  recipientName: string;
  recipientEmail: string;
  ccEmails?: string[];
}

function generateAccountingEmailDraft(params: AccountingEmailParams): DraftEmailOptions {
  const { authorName, stateName, stateAbbrev, chapterTitle, chapterNum, recipientName, ccEmails } = params;

  const subject = `[GEODE] New Contractor Setup in Gusto - ${authorName} - ${stateAbbrev} Ch ${chapterNum}`;

  const body = `Hi ${recipientName},

We have a new contractor to set up in Gusto. The contract has been signed.

**Contractor Details:**
- Name: ${authorName}
- Email: ${params.authorEmail}
- Project: GEODE ${stateName} State Report
- Assignment: Chapter ${chapterNum} - ${chapterTitle}
- Role: Bylined Chapter Author

Per SOP, please:
1. Set up the contractor in Gusto
2. Trigger the onboarding email from Gusto to the contractor
3. Save the executed agreement to the Admin Google Share drive in the Contractor folder

The signed contract details have been uploaded to Monday.com â†’ GEODE Payments board under the appropriate state group.

Let me know if you need any additional information.

Thank you!

---
_This draft was generated by Wellspring._`;

  return {
    to: [params.recipientEmail],
    cc: ccEmails,
    subject,
    body,
    isHtml: false,
  };
}

// ============================================
// ACTION EXECUTORS
// ============================================

/**
 * Execute: generate_contract
 * Creates a draft email to Dani with contract details
 */
async function executeGenerateContract(
  action: GeodeSuggestedAction,
  task: GeodeConfirmationTask
): Promise<ActionExecutionResult> {
  if (!isGmailConnected()) {
    return {
      actionId: action.id,
      success: false,
      message: 'Gmail is not connected. Please connect your Google account in Settings.',
    };
  }

  const stateInfo = task.state ? GEODE_STATES.find(s => s.value === task.state) : null;
  const chapterInfo = task.chapterType ? GEODE_CHAPTER_TYPES.find(c => c.value === task.chapterType) : null;

  if (!stateInfo || !chapterInfo || !task.authorName || !task.authorEmail) {
    return {
      actionId: action.id,
      success: false,
      message: 'Missing required information (state, chapter, author name, or email)',
    };
  }

  // For now, just note that this would generate the contract
  // The actual PDF generation would require a template system
  return {
    actionId: action.id,
    success: true,
    message: `Contract generation noted for ${task.authorName}. PDF generation pending implementation.`,
    artifacts: [
      {
        type: 'log_entry',
        details: {
          action: 'contract_generation_requested',
          authorName: task.authorName,
          state: stateInfo.value,
          chapter: chapterInfo.value,
        },
      },
    ],
  };
}

/**
 * Execute: send_contract
 * Creates a draft email to the specified recipient (usually Dani) about the contract
 *
 * Attachment lookup priority:
 * 1. Local PDF in "GEODE Signature Ready Contracts" folder (preferred)
 * 2. Local PDF converted from Word doc (if Word doc exists but no PDF)
 * 3. Fallback to Gmail search for attachments
 */
async function executeSendContract(
  action: GeodeSuggestedAction,
  task: GeodeConfirmationTask
): Promise<ActionExecutionResult> {
  if (!isGmailConnected()) {
    return {
      actionId: action.id,
      success: false,
      message: 'Gmail is not connected. Please connect your Google account in Settings.',
    };
  }

  const stateInfo = task.state ? GEODE_STATES.find(s => s.value === task.state) : null;
  const chapterInfo = task.chapterType ? GEODE_CHAPTER_TYPES.find(c => c.value === task.chapterType) : null;

  if (!stateInfo || !chapterInfo || !task.authorName || !task.authorEmail) {
    return {
      actionId: action.id,
      success: false,
      message: 'Missing required information (state, chapter, author name, or email)',
    };
  }

  const recipientEmail = action.params.toEmail || 'dani@projectinnerspace.org';
  const recipientName = action.params.toName || 'Dani';
  const ccEmails = action.params.ccEmails ? action.params.ccEmails.split(',').map(e => e.trim()) : undefined;

  const emailOptions = generateContractEmailDraft({
    authorName: task.authorName,
    authorEmail: task.authorEmail,
    stateName: stateInfo.label,
    stateAbbrev: stateInfo.abbreviation,
    chapterTitle: chapterInfo.label,
    chapterNum: chapterInfo.chapterNum,
    recipientName,
    recipientEmail,
    ccEmails,
  });

  // Try to get the contract attachment
  let attachment: { filename: string; mimeType: string; content: string } | undefined;
  let attachmentSource = '';

  // PRIORITY 1: Search for PDF in local contracts folder (file server)
  console.log('[ActionExecutor] Searching for local contract files...');
  try {
    const searchResponse = await fetch(
      `http://localhost:3002/api/contracts/search?` +
      `authorName=${encodeURIComponent(task.authorName || '')}` +
      `&stateAbbrev=${encodeURIComponent(stateInfo.abbreviation)}` +
      `&chapterTitle=${encodeURIComponent(chapterInfo.label)}`
    );

    if (searchResponse.ok) {
      const searchResult = await searchResponse.json();
      console.log('[ActionExecutor] Local contract search result:', searchResult);

      // Prefer signature-ready PDF
      let localFilePath = searchResult.signatureReadyPdf?.path || searchResult.pdf?.path;

      // If only Word doc exists, try to convert it to PDF
      if (!localFilePath && searchResult.wordDoc?.path) {
        console.log('[ActionExecutor] Found Word doc, attempting PDF conversion...');

        const convertResponse = await fetch('http://localhost:3002/api/contracts/convert-to-pdf', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wordDocPath: searchResult.wordDoc.path,
            // Output to signature-ready folder
            outputPdfPath: searchResult.wordDoc.path
              .replace('/contracts/', '/contracts/GEODE Signature Ready Contracts/')
              .replace(/\.docx?$/i, '.pdf'),
          }),
        });

        if (convertResponse.ok) {
          const convertResult = await convertResponse.json();
          if (convertResult.success) {
            localFilePath = convertResult.pdfPath;
            console.log('[ActionExecutor] PDF conversion successful:', localFilePath);
          }
        }
      }

      // Read the local file if found
      if (localFilePath) {
        const readResponse = await fetch(
          `http://localhost:3002/api/files/read?path=${encodeURIComponent(localFilePath)}`
        );

        if (readResponse.ok) {
          const fileData = await readResponse.json();
          attachment = {
            filename: fileData.filename,
            mimeType: fileData.mimeType,
            content: fileData.data,
          };
          attachmentSource = localFilePath.includes('Signature Ready')
            ? 'local (signature-ready folder)'
            : 'local (contracts folder)';
          console.log('[ActionExecutor] Successfully loaded local contract:', fileData.filename);
        }
      }
    }
  } catch (error) {
    console.warn('[ActionExecutor] Local file server not available:', error);
  }

  // PRIORITY 2: Check if task has a stored contract attachment reference (from Gmail)
  if (!attachment && task.contractAttachment) {
    console.log('[ActionExecutor] Trying stored contract attachment reference:', task.contractAttachment);
    try {
      const attachmentData = await getAttachment(
        task.contractAttachment.sourceEmailId,
        task.contractAttachment.attachmentId
      );
      attachment = {
        filename: task.contractAttachment.filename,
        mimeType: task.contractAttachment.mimeType,
        content: attachmentData.data,
      };
      attachmentSource = 'stored reference';
      console.log('[ActionExecutor] Successfully retrieved attachment from stored reference');
    } catch (error) {
      console.warn('[ActionExecutor] Failed to get attachment from stored reference:', error);
    }
  }

  // PRIORITY 3: Search Gmail for contract attachment (fallback)
  if (!attachment) {
    console.log('[ActionExecutor] Searching Gmail for contract attachment...');

    const searchQueries = [
      `to:${task.authorEmail} has:attachment in:sent`,
      `to:${task.authorName?.split(' ')[0]} has:attachment in:sent`,
      task.state ? `subject:"${stateInfo?.abbreviation || ''} Geothermal Report" has:attachment in:sent` : null,
      task.state ? `subject:${stateInfo?.label || task.state} has:attachment in:sent` : null,
      `subject:agreement has:attachment in:sent`,
      `subject:contract has:attachment in:sent`,
    ].filter(Boolean) as string[];

    for (const searchQuery of searchQueries) {
      console.log('[ActionExecutor] Trying Gmail search:', searchQuery);
      const found = await findEmailWithAttachment(searchQuery, undefined, true);

      if (found.message && found.attachment) {
        // Prefer PDF over Word doc from Gmail
        if (found.attachment.mimeType === 'application/pdf' ||
            !attachment ||
            attachment.mimeType !== 'application/pdf') {
          console.log('[ActionExecutor] Found attachment in Gmail:', found.attachment.filename);
          try {
            const attachmentData = await getAttachment(
              found.message.id,
              found.attachment.attachmentId
            );
            attachment = {
              filename: found.attachment.filename,
              mimeType: found.attachment.mimeType,
              content: attachmentData.data,
            };
            attachmentSource = 'gmail';

            // If we found a PDF, stop searching
            if (found.attachment.mimeType === 'application/pdf') {
              break;
            }
          } catch (error) {
            console.warn('[ActionExecutor] Failed to retrieve Gmail attachment:', error);
          }
        }
      }
    }
  }

  // Create draft with or without attachment
  let result;
  if (attachment) {
    console.log(`[ActionExecutor] Creating draft with attachment from ${attachmentSource}:`, attachment.filename);
    result = await createDraftWithAttachment({
      ...emailOptions,
      attachment,
    });
  } else {
    console.log('[ActionExecutor] No attachment found, creating draft without attachment');
    result = await createDraft(emailOptions);
  }

  if (result.success) {
    const isPdf = attachment?.mimeType === 'application/pdf';
    return {
      actionId: action.id,
      success: true,
      message: attachment
        ? `Draft email created to ${recipientName} with ${isPdf ? 'PDF' : 'Word doc'} attached (${attachment.filename}) [source: ${attachmentSource}]`
        : `Draft email created to ${recipientName} about ${task.authorName}'s contract (no attachment found - please add manually)`,
      artifacts: [
        {
          type: 'draft',
          id: result.draftId,
          url: `https://mail.google.com/mail/u/0/#drafts`,
          details: {
            to: recipientEmail,
            cc: ccEmails,
            subject: emailOptions.subject,
            hasAttachment: !!attachment,
            attachmentName: attachment?.filename,
            attachmentSource,
            isPdf,
          },
        },
      ],
    };
  } else {
    return {
      actionId: action.id,
      success: false,
      message: result.error || 'Failed to create email draft',
    };
  }
}

/**
 * Execute: advance_step
 * Would update the chapter workflow state
 */
async function executeAdvanceStep(
  action: GeodeSuggestedAction,
  task: GeodeConfirmationTask
): Promise<ActionExecutionResult> {
  const newStep = action.params.newStep;

  if (!newStep) {
    return {
      actionId: action.id,
      success: false,
      message: 'No target step specified',
    };
  }

  // This would integrate with the geodeChapterStore
  // For now, we'll return success and let the UI handle the actual update
  return {
    actionId: action.id,
    success: true,
    message: `Chapter status should be updated to: ${newStep}`,
    artifacts: [
      {
        type: 'status_update',
        details: {
          newStep,
          state: task.state,
          chapterType: task.chapterType,
        },
      },
    ],
  };
}

/**
 * Execute: log_communication
 * Logs author information to the chapter record
 */
async function executeLogCommunication(
  action: GeodeSuggestedAction,
  task: GeodeConfirmationTask
): Promise<ActionExecutionResult> {
  // This would integrate with the geodeChapterStore to save author info
  return {
    actionId: action.id,
    success: true,
    message: `Logged: ${task.authorName} (${task.authorEmail}) for ${task.state} ${task.chapterType}`,
    artifacts: [
      {
        type: 'log_entry',
        details: {
          authorName: task.authorName,
          authorEmail: task.authorEmail,
          state: task.state,
          chapterType: task.chapterType,
        },
      },
    ],
  };
}

/**
 * Execute: notify_accounting
 * Creates a draft email to accounting team about new contractor setup
 */
async function executeNotifyAccounting(
  action: GeodeSuggestedAction,
  task: GeodeConfirmationTask
): Promise<ActionExecutionResult> {
  if (!isGmailConnected()) {
    return {
      actionId: action.id,
      success: false,
      message: 'Gmail is not connected. Please connect your Google account in Settings.',
    };
  }

  const stateInfo = task.state ? GEODE_STATES.find(s => s.value === task.state) : null;
  const chapterInfo = task.chapterType ? GEODE_CHAPTER_TYPES.find(c => c.value === task.chapterType) : null;

  if (!stateInfo || !chapterInfo || !task.authorName || !task.authorEmail) {
    return {
      actionId: action.id,
      success: false,
      message: 'Missing required information (state, chapter, author name, or email)',
    };
  }

  const recipientEmail = action.params.toEmail || 'accounting@projectinnerspace.org';
  const recipientName = action.params.toName || 'Accounting Team';
  const ccEmails = action.params.ccEmails ? action.params.ccEmails.split(',').map(e => e.trim()) : undefined;

  const emailOptions = generateAccountingEmailDraft({
    authorName: task.authorName,
    authorEmail: task.authorEmail,
    stateName: stateInfo.label,
    stateAbbrev: stateInfo.abbreviation,
    chapterTitle: chapterInfo.label,
    chapterNum: chapterInfo.chapterNum,
    recipientName,
    recipientEmail,
    ccEmails,
  });

  const result = await createDraft(emailOptions);

  if (result.success) {
    return {
      actionId: action.id,
      success: true,
      message: `Draft email created to ${recipientName} for contractor setup`,
      artifacts: [
        {
          type: 'draft',
          id: result.draftId,
          url: `https://mail.google.com/mail/u/0/#drafts`,
          details: {
            to: recipientEmail,
            cc: ccEmails,
            subject: emailOptions.subject,
          },
        },
      ],
    };
  } else {
    return {
      actionId: action.id,
      success: false,
      message: result.error || 'Failed to create accounting email draft',
    };
  }
}

/**
 * Execute: upload_contract_monday
 * Adds author to the GEODE Payments board under the appropriate state group
 * Per SOP: Contract owner uploads contract details to Monday.com
 * Board: GEODE Payments - Report Contributors (5640622226)
 */
async function executeUploadContractMonday(
  action: GeodeSuggestedAction,
  task: GeodeConfirmationTask
): Promise<ActionExecutionResult> {
  const stateInfo = task.state ? GEODE_STATES.find(s => s.value === task.state) : null;
  const chapterInfo = task.chapterType ? GEODE_CHAPTER_TYPES.find(c => c.value === task.chapterType) : null;

  if (!stateInfo || !chapterInfo || !task.authorName || !task.authorEmail) {
    return {
      actionId: action.id,
      success: false,
      message: 'Missing required information (state, chapter, author name, or email)',
    };
  }

  // Check if Monday.com API token is configured
  const mondayToken = localStorage.getItem('monday_api_token');
  if (!mondayToken) {
    return {
      actionId: action.id,
      success: false,
      message: 'Monday.com is not connected. Please configure API token in Settings.',
    };
  }

  // Import dynamically to avoid circular dependencies
  const { addAuthorToPaymentsBoard } = await import('./mondayService');

  const result = await addAuthorToPaymentsBoard(mondayToken, {
    name: task.authorName,
    email: task.authorEmail,
    state: task.state || '',
    chapterType: task.chapterType || '',
    chapterTitle: chapterInfo.label,
    chapterNum: chapterInfo.chapterNum,
    contractSignedDate: new Date().toISOString().split('T')[0],
  });

  if (result.success) {
    return {
      actionId: action.id,
      success: true,
      message: `Author added to GEODE Payments board under ${stateInfo.label} group (Item ID: ${result.itemId})`,
      artifacts: [
        {
          type: 'status_update',
          id: result.itemId,
          url: action.params.boardUrl || 'https://projectinnerspace.monday.com/boards/5640622226',
          details: {
            itemId: result.itemId,
            author: task.authorName,
            state: stateInfo.label,
            chapter: `${chapterInfo.chapterNum} - ${chapterInfo.label}`,
          },
        },
      ],
    };
  } else {
    return {
      actionId: action.id,
      success: false,
      message: result.error || 'Failed to add author to Payments board',
    };
  }
}

/**
 * Execute: send_welcome_email
 * Creates a draft welcome email to the author with next steps
 * Per SOP: Contract owner sends executed agreement to contractor and communicates next steps
 */
async function executeSendWelcomeEmail(
  action: GeodeSuggestedAction,
  task: GeodeConfirmationTask
): Promise<ActionExecutionResult> {
  if (!isGmailConnected()) {
    return {
      actionId: action.id,
      success: false,
      message: 'Gmail is not connected. Please connect your Google account in Settings.',
    };
  }

  const stateInfo = task.state ? GEODE_STATES.find(s => s.value === task.state) : null;
  const chapterInfo = task.chapterType ? GEODE_CHAPTER_TYPES.find(c => c.value === task.chapterType) : null;

  if (!stateInfo || !chapterInfo || !task.authorName || !task.authorEmail) {
    return {
      actionId: action.id,
      success: false,
      message: 'Missing required information (state, chapter, author name, or email)',
    };
  }

  const subject = `Welcome to GEODE! Next Steps for ${stateInfo.label} Ch ${chapterInfo.chapterNum}`;

  // Per SOP sample email - adjusted since Gusto is being migrated
  const body = `Dear ${task.authorName},

Attached is the fully executed agreement for your files. I am excited to kick off our work together!

**Next Steps:**

1. **Payment Setup**: Our accounting team will be in touch shortly to set up your contractor profile for payment processing. You'll receive an email with instructions to complete your profile and submit direct deposit details.

2. **Invoicing**: On the first of each month, please email an invoice to me for approval. By the 15th of each month, you will be paid by direct deposit.

3. **Chapter Materials**: I'll be sharing the chapter outline and reference materials with you shortly.

**Your Assignment:**
- Report: GEODE ${stateInfo.label} State Geothermal Data Report
- Chapter: ${chapterInfo.chapterNum} - ${chapterInfo.label}

Please let me know if you have any questions about anything.

Looking forward to working with you!

Best regards,
Trent McFadyen

---
_This draft was generated by Wellspring._`;

  const emailOptions: DraftEmailOptions = {
    to: [task.authorEmail],
    subject,
    body,
    isHtml: false,
  };

  const result = await createDraft(emailOptions);

  if (result.success) {
    return {
      actionId: action.id,
      success: true,
      message: `Welcome email draft created for ${task.authorName}`,
      artifacts: [
        {
          type: 'draft',
          id: result.draftId,
          url: `https://mail.google.com/mail/u/0/#drafts`,
          details: {
            to: task.authorEmail,
            subject,
          },
        },
      ],
    };
  } else {
    return {
      actionId: action.id,
      success: false,
      message: result.error || 'Failed to create welcome email draft',
    };
  }
}

// ============================================
// MAIN EXECUTOR
// ============================================

/**
 * Execute a single action
 */
export async function executeAction(
  action: GeodeSuggestedAction,
  task: GeodeConfirmationTask
): Promise<ActionExecutionResult> {
  console.log('[ActionExecutor] Executing action:', action.id, action.actionType);

  switch (action.actionType) {
    case 'generate_contract':
      return executeGenerateContract(action, task);

    case 'send_contract':
      return executeSendContract(action, task);

    case 'advance_step':
      return executeAdvanceStep(action, task);

    case 'log_communication':
      return executeLogCommunication(action, task);

    case 'notify_accounting':
      return executeNotifyAccounting(action, task);

    case 'upload_contract_monday':
      return executeUploadContractMonday(action, task);

    case 'send_welcome_email':
      return executeSendWelcomeEmail(action, task);

    default:
      return {
        actionId: action.id,
        success: false,
        message: `Unknown action type: ${action.actionType}`,
      };
  }
}

/**
 * Execute all actions for a confirmation task
 */
export async function executeTaskActions(
  task: GeodeConfirmationTask
): Promise<TaskExecutionResult> {
  console.log('[ActionExecutor] Executing task:', task.id, 'with', task.pendingActions.length, 'actions');

  const results: ActionExecutionResult[] = [];
  let allSuccess = true;

  for (const action of task.pendingActions) {
    // When user clicks "Confirm & Execute", they're confirming ALL actions
    // So we execute everything regardless of requiresConfirmation flag
    const result = await executeAction(action, task);
    results.push(result);

    if (!result.success) {
      allSuccess = false;
    }
  }

  // Generate summary
  const successCount = results.filter(r => r.success).length;
  const failCount = results.filter(r => !r.success).length;

  let summary: string;
  if (allSuccess) {
    summary = `Successfully executed ${successCount} action${successCount !== 1 ? 's' : ''}`;
  } else if (successCount > 0) {
    summary = `Executed ${successCount} action${successCount !== 1 ? 's' : ''}, ${failCount} failed`;
  } else {
    summary = `All ${failCount} action${failCount !== 1 ? 's' : ''} failed`;
  }

  // Add draft link to summary if we created one
  const draftArtifact = results.flatMap(r => r.artifacts || []).find(a => a.type === 'draft');
  if (draftArtifact) {
    summary += '. Check your Gmail drafts!';
  }

  return {
    taskId: task.id,
    success: allSuccess,
    results,
    summary,
  };
}

/**
 * Check if actions can be executed (Gmail connected, etc.)
 */
export function canExecuteActions(): { ready: boolean; issues: string[] } {
  const issues: string[] = [];

  if (!isGmailConnected()) {
    issues.push('Gmail is not connected');
  }

  return {
    ready: issues.length === 0,
    issues,
  };
}
